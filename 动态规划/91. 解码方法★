91. 解码方法

一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例 1:

输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2:

输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

★思路：-------------
（1）01 02 这种0在开头的是无法解析的，返回0
（2）假如只有一个数字，那么解析只有1种
（3）当数字个数>=2时：对于1502或者2794这种有0但是0前面数字不是1或者2的，是无法解析的。因为00吧没有这样的，40，50又超出解码范围(1~26)
（4）对于 110或者320这种有0，并且0前面数字是1或者2时，他只能组成10，或者20,因此dp[index]=dp[index-2]，即当前位置的解密个数=扣掉最后的10或20剩下
     的序列的解密个数。
（5）对于那些当前位置不是0，且该位置前面的元素是1或者2时，比如13，可分为1 3 或者13，分为1 3 时，扣掉3，剩下的序列解密个数是dp[i-1]，当分为13时，
     剩下的序列解密个数时dp[i-2]。故此时dp[i]=dp[i-2]+dp[i-1]
（6）剩下的情况是当前位置的元素不是0，且该位置的前一个元素是0或者3，4，5，6，7，8，9的某一个，比如65，他不能解密，只能分成6和5，故
     dp[i] = dp[i-1]
     
     
  class Solution(object):
    def numDecodings(self, s):
        """
        :type s: str
        :rtype: int
        """
        dp=[0 for _ in range((len(s)+1))]
        if s[0]!='0':
            dp[0],dp[1]=1,1
        else:
            return 0
        
        if len(s)>=2:
            for index in range(2,len(s)+1):
                #当前为0而前一位不是1或2,就无解，跳出循环，此时的dp[len(s)]也正好没处理过，是初始化的0
                if s[index-1]=='0' and s[index-2]!='1'and s[index-2]!='2':
                    break
                #当前为0且前一位是1或2，那么只能解读为10或20，解数是dp[index-2]
                elif s[index-1]=='0':
                    dp[index]=dp[index-2]
                #前一位为1,或者（前一位为2但当前小于7），当前x。以前一位为1举例，解数为dp[index-2](解读为1x)+dp[index-1](解读为1，x)
                elif s[index-2]=='1' or (s[index-2]=='2' and int(s[index-1])<7):
                    dp[index]=dp[index-2]+dp[index-1]
                #前一位大于2或者等于0（或者为2但当前大于6）此时的解数和dp[index-1]相同，因为x只能被单独解读
                else:
                    dp[index]=dp[index-1]
        return dp[len(s)]
