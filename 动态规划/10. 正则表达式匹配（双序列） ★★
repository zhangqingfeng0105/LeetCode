★★ 10. 正则表达式匹配 

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false



★★ 思路;----------------------------------------------

如果B[n-1]是一个正常字符(非.非*),则如果A[m-1]=B[n-1]，能否匹配取决于A[0,..m-2]和B[0,..n-2]是否匹配,否则不能匹配

如果B[n-1]是.，则A[m-1]一定和.匹配，之后是否匹配取决于A[0,..m-2]和B[0,..n-2]是否匹配

如果B[n-1]是*,他代表B[n-2]=c重复0次或多次（这时B的最后一个字符是*，倒数第二个字符是c,c可能是字母或者.），他们是一个整体c*，需要考虑A[m-1]是
0个c还是多个c中的最后一个。
(1) 假如A[m-1]是0个c，能否匹配取决于A[0,..m-1]和B[0,..n-3]是否匹配
(2) 假如A[m-1]是多个c的最后一个，能否匹配取决于A[0,..m-2]和B[0,..n-1]是否匹配，这个情况下，A[m-1]=c或者c=.

状态方程：
设  f[i][j] 为A前i个字符A[0,..i-1]和B前j个字符能否匹配

                 f[i-1][j-1] 如果B[j-1]=. 或者A[i-1]=B[j-1]
   f[i][j]  = 
                 f[i][j-2] or (f[i-1][j]  AND (B[j-2]=.  or B[j-2]=A[i-1] ))   如果 B[j-1]=*
                 情况一               情况二

边界情况：
空串和空正则表达式匹配：   f[0][0] = True
空的正则表达式不能匹配长度>0的串  f[1][0] = ... f[m][0] = False

答案是 f[m][n]


class Solution(object):
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        m, n = len(s), len(p)
        f = [[False for j in range(n+1)] for i in range(m+1)]           
        for i in range(m+1):
            for j in range(n+1):
                if i == 0 and j== 0:      # 字符串s是空，正则表达式也是空，可以匹配
                    f[i][j] = True
                    continue
                
                if j == 0:            #  正则表达式为空，串不是空，不能匹配
                    f[i][j] = False  
                    continue
                    
                if p[j-1] != '*':    #  f[i-1][j-1] 如果B[j-1]=. 或者A[i-1]=B[j-1]                                    
                    if i > 0 and (p[j-1] == '.' or s[i-1] == p[j-1]):
                        f[i][j] = f[i-1][j-1]
                        
                else:                # f[i][j-2] or (f[i-1][j]  AND (B[j-2]=.  or B[j-2]=A[i-1] ))   如果 B[j-1]=*
                    if j-2 >= 0:  
                        f[i][j] |= f[i][j-2]
                    if i >= 1 and j >= 2:
                        f[i][j] |= (f[i-1][j] and (p[j-2] == '.' or p[j-2] == s[i-1]))
        return f[m][n]

