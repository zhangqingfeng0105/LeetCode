174. 地下城游戏

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

 

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。
tungion = 
-2 	-3	3
-5	-10	1
10	30	-5 


思路：
本题就是从左上角到达右下角，并且经过一个格的最少血量是1，那么要想得到初始的最少血量，我们需要从右下角倒叙遍历到左上角，
对于示例：右下角为-5，并且经过-5后血量必须是>=1，我们为了得到最小的初始血量，因此在经过-5前，血量要为6，6-5=1>0，符合要求，
我们可以设置一个dp，dp跟给定参数tungeon是同结构，只不过初始值用0填充，即dp初始样子是：
0 0 0
0 0 0
0 0 0
dp[i][j]保存的是经过第i行第j列格子前最少的血量。我们又是从右下倒序遍历到左上，因此右下角元素dp[-1][-1] = 1-（-5）=6，经过最右下角格子之前骑士
的血量应该为6，我们通过倒序把dp的最后一行也填充一下，对于30这个格子(tungeon[2][1])，经过这个格子之后的血量是6，这个格子又是加30血，但又要保证
骑士无时无刻血量>=1，因此在经过30这个格子之前，血量应该是1，虽然根据减法6-30=-24，假如没有骑士无时无刻血量>=1这个条件，那么经过30这个格子之前，
血量最少是-24,但是现在有了这个条件了，故经过30这个格子之前血量最小是1，由此我们可以看出dp的最后一行的更新规则是：max(1,dp[-1][i+1]-tungeon[-1][i])
而dp最后一列的填充规则是：max(1,dp[j+1][-1]-dungeon[j][-1])，对于dp的内部，即除去最后一行，最后一列的剩余的部分。它的更新规则是比较这个位置的
下边和右边，取两者最小的值，即最小的值意味着经过这个格后的最小血量，满足题意，得到最小值后，再用这个格子的值减去tungeon[i][j]，得到的结果与
1比较，这样跟边界上的更新规则一致，就是多了个比较下边和右边元素。


class Solution(object):
    def calculateMinimumHP(self, dungeon):
        """
        :type dungeon: List[List[int]]
        :rtype: int
        """
        if len(dungeon) == 0:
            return 1

        dp = [[0 for i in range(len(dungeon[0]))] for j in range(len(dungeon))]
        dp[-1][-1] = max(1,1- dungeon[-1][-1])
        for i in range(len(dungeon[0])-2,-1,-1):
            dp[-1][i] = max(1,dp[-1][i+1]-dungeon[-1][i])
        for j in range(len(dungeon)-2,-1,-1):
            dp[j][-1] = max(1,dp[j+1][-1]-dungeon[j][-1])
            for m in range(len(dungeon[0])-2,-1,-1):
                dp[j][m] = max(1,min(dp[j+1][m],dp[j][m+1]) - dungeon[j][m])
        return dp[0][0]
