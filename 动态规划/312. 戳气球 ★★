★★ 312. 戳气球

有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。

求所能获得硬币的最大数量。

说明:

你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100

示例:

输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167


★★ 思路： ---------------------------

扎气球，我们在原来的气球列表中在头上添加一个气球0得分1，在末尾添加一个气球N得分1，这样我们只要保证头气球0和尾气球N不被扎破，然后分开计算每一个区间，
比如示例1，4个气球，的分发分别是[3,1,5,8]，我们在头尾添加得分是1的气球，即：[1,3,1,5,8,1]，每次气球0和气球N不能扎破(N=5)，扎1-4气球，假设最后一个
被扎破的气球是i(1<= i <= 4)，那么可分为两段，0-i为一段，其中0和i气球不能被扎破，第二段i - N，其中 i 和N不能被扎破，两段分别加起来的得分加上第i个气球
的得分，就是最后扎破i气球的得分。

设 dp[i][j] 为 i+1 ~ j-1 区间气球的最佳得分  i 和 j不能被扎破

           dp[i][j]            =          max (  dp[i][k]     +     dp[k][j]  +      a[i]  * a[k]  * a[j]  )   其中  i < k  <j
扎破i+1~j-1号气球的最佳得分      扎破i+1~k-1号气球的最佳得分     扎破k+1~j-1号气球的最佳得分   最后扎破k号气球的得分


class Solution(object):
    def maxCoins(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        if n == 0:
            return 0
        A = [1] + nums + [1]       # 头尾插入一个气球,得分是1
        dp = [[0 for i in range(n+2)] for j in range(n+2)]
        for size in range(3,n+2+1):    # 从长度3开始，也就是区间内的元素个数(包含左端和右端点)
            for i in range(n-size+2+1):   # i和j分别代表这个区间的头和尾，i最大是n+1-size
                j = i+size-1           # j是区间的右端，他的下标是i+size-1
                for k in range(i+1,j):     # 在区间[i,j]中枚举最后一个戳破的气球k,k的取值范围是[i+1,j-1]
                    dp[i][j] = max(dp[i][j],dp[i][k]+dp[k][j]+A[i]*A[k]*A[j])                  
        return dp[0][n+1]    # 返回区间[0,N+1]的最大得分，dp[i][j]表示扎破i+1~j-1号气球的最佳得分 
 
